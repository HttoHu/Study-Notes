# 第三章

## 3.4 访问信息

一个x86-64的中央处理单元包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。以下为常用寄存器

64 |32|16|8|funtion
-|-|-|-|-|
%rax| %eax|%ax|%al|返回值
%rbx| %ebx|%bx|%bl|被调用这保存
%rcx| %ecx|%cx|%cl|第四个参数
%rdx| %edx|%ax|%dl|第三个参数
%rsi| %esi|%ax|%si|第二个参数
%rdi| %edi|%di|%dil|第一个参数
%rbp| %ebp|%bp|%bpl|被调用者保存
%rsp| %esp|%sp|%spl|栈指针
%r8| %r8d|%r8w|%r8b|第五个参数
%r9| %r9d|%r9w|%r9b|第六个参数
%r10| %r10|%r10w|%r10b|调用者保存
%r11| %r11|%r11w|%r11b|调用者保存
%r12| %r12|%r12w|%r12b|调用者保存
%r13| %r13|%r13w|%r13b|调用者保存
%r14| %r14|%r14w|%r14b|调用者保存
%r15| %r15|%r15w|%r15b|调用者保存

### 3.4.1 操作数指示符

大多数指令有一个或多个操作数(operand),指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。x86-64支持多种操作格式。元数据可以以常数形式给出，或者从寄存器或内存中读出。结果可以放在寄存器或内存中。因此，各种不同操作数可以分成三种类型:

1. 立即数(immediate):用来表示常数值，在ATT格式的汇编代码中，立即数的书写方式是'$'后面跟一个用标准C表示法表示的整数, 比如, $-577或 $0x1F。
2. 寄存器(register),它表示某个寄存器的内容。我们用R[寄存器名称]代表其值
3. 内存引用，她会根据计算出来的地址（通常称为有效地址)访问某个内存位置。

寻址的模式
|类型|格式|操作数值|名称|
|--|--|-|-|
|立即数|$Imm|Imm|立即数寻址|
|寄存器|r_a|R[r_a]|寄存器寻址
|存储器|Imm|M[Imm]|绝对寻址|
|存储器|(r_a)|M[R[r_a]]|间接寻址|
|存储器|Imm(r_b)|M[Imm+R[r_a]]|(基址+偏移量)寻址|
|存储器|（r_b,r_i)|M[R[r_b]+R[r_i]]|变址寻址|
|存储器|（Imm(r_b,r_i)|M[Imm+R[r_b]+R[r_i]]|变址寻址|
|存储器|（r_i,s)|M[R[r_i]*s]|比例变址寻址|
|存储器|Imm（r_i,s)|M[Imm+R[r_i]*s]|比例变址寻址|
|存储器|（r_b,r_i,s)|M[R[r_b]+R[r_i]*s]|比例变址寻址|
|存储器|Imm（r_b,r_i,s)|M[Imm+R[r_b]+R[r_i]*s]|比例变址寻址|

例如: %rax, 0x104, $0x104, (%rax), 4(%rax), 9(%rax,%rdx), 260(%rcx,%rdx)

0xFC(,%rcx,4),(%rax,%rdx,4)

### **3.4.2 数据传递指令**
最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功能。

MOV类有四类指令组成，movb, movw,movl 和movq, 分别是1,2,3,8字节

MOV S,D 效果 D<-S,源操作数的值一定是一个立即数，存储在寄存器中或者内容中。目的操作数指定一个位置，要么是一个寄存器或者，要么是一个内存地址，传送指令两个操作数不能指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令-第一条指令将源值加载到寄存器中，第二条指令将改寄存器的值写入到目的位置。

还有一族MOVZ系列指令, MOVZ(S,R)相当于R<-零拓展的(S)，有以下
1. movzw 零拓展的字节传送到字
2. movzbl 零拓展的字节传送到双字
3. movzwl 零拓展的字传送到双子
4. movzbq 将做了零拓展的字节传送到四字
5. movzwq 将做了零拓展的字传送到四字

同样有符号的拓展是MOVS 族指令，后缀和MOVZ一样。注意有一个
* cltq 指令把%eax符号拓展到%rax

## **3.4.3 数据传送示例**
```c
long exchange(long *xp,long y)
{
    long x=*xp;
    *xp=y;
    return x
}
```
```asm
# xp in %rdi, y in %rsi
1 exchange:
2   movq (%rdi),%rax
3   movq %rsi,(%rdi)
4   ret
```
##  **3.4.4  压入和弹出数据**
* pushq S:将四字压入栈
* pop D,将四字弹出栈

pushq指令的功能是把数据压入栈中，而popq指令则是弹出数据。这些指令都只有一个操作数---压入的数据源和弹出 的数据目的.

将一个四字压入栈中，首先要将栈指针8， 然后将值写道新的栈顶地址。

# 算术和逻辑操作
指令|效果|描述
-|-|-
leaq S,D|&S->D|加载有效地址
INC D|D+1->D加一
DEC D|D-1->D|减一
NEG D|-D->D|取负
NOT D|~D->D|取非
ADD S,D|D+S->D|加
SUB S,D|D+S->D|减
IMUL S,D|D*S->D|乘
XOR S,D|D^S->D|异或
OR S,D|D\|S->D|或
AND S,D|D&S->D|与
SAL k,D|D<<k->D|左移
SHL k,D|D<<k->D|左移(同SAL)
SAR k,D|D>>k->D|左算术右移
SHL k,D|D>>>k->D|逻辑右移

## 3.5.1 加载有效地址
加载有效地址(load effective address)指令leaq其实是movq指令的变形。它的指令形式是从内存读取数据到寄存器，但实际上它更笨就没有引用内存。它的第一个操作数看上去是一个内存引用。但该指令并不是从指定的位置读入数据，二十将有效地址写入到目的的操作数。另外，它还可以简洁的描述普通的算术操作。例如，如果寄存器%rdx的值为x, 那么指令leaq 7(%rdx,%rdx,4), %rax 将设置寄存器%rax为5x+7.编译器经常发现leaq的一些灵活用法和有效地址无关。目的操作数必须是一个寄存器。

```c
long scale(long x,long y,long z)
{
    long t=x+4*y+12*z;
    return t;
}
```
编译时，改函数的算术运算以三条leaq指令实现
```
scale:
    leaq (%rdi,%rsi,4),%rax
    leaq (%rdx,%rdx,2),%rdx
    leaq (%rax,%rdx,4),%rax
    ret
```
leaq指令能够执行加法和有限形式的乘法，在编译器如上简单的算术表达式时是很有用处的.