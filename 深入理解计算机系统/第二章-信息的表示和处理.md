S# 第二章：信息的表示和处理

## 2.1 信息存储
* 大端法: 从左到右(我们人类喜欢的顺序)
* 小端法: 从右到左
```c
#include <stdio.h>

typedef unsigned char* byte_pointer;
void show_bytes(byte_pointer start, size_t len)
{
	size_t i;
	for (int i = 0; i < len; i++)
		printf(" %.2x", start[i]);
	printf("\n");
}

void show_int(int x)
{
	show_bytes((byte_pointer)& x, sizeof(int));
}

void show_float(float x)
{
	show_bytes((byte_pointer)& x, sizeof(float));
}


void show_pointer(void* x)
{
	show_bytes((byte_pointer)& x, sizeof(void*));
}

```

以上代码显示一个数值的16进制，你可以用来检测你的机器使用大端还是小端

## 2.1.9 C语言中的位移运算
* 左移: 对于一个位表示
$$ 
    [x_{\omega-1},x_{\omega-2},x_{\omega-3},...,x_0]的操作数x,C表达式x<<k会生成一个值，其位表示为
    [x_{\omega-k-1},x_{\omega-k-2},x_{\omega-k-3},...,x_0,0...,0]. 也就是说，x向左移动k位，丢弃最高的k位，并在右端补上k个0.移动量应该是0-\omega-1的值.
$$
* 右移：右移分为逻辑右移和算数右移。逻辑右移就是在左端补k个0，算术位移就是在左端补k个最高有效位的值。
* 移动k位，这里k很大我们对一个n位的数据x移动k位,k>n,我们执行x>>k这里首先实际上计算了x>>(k mod n), 同理<<也是如此.

## 2.2 整数表示
所用到的函数:

1. $$ B2T_\omega 二进制转补码 $$
2. $$ B2U_\omega 二进制转无符号数 $$
3. $$ 依次类推，我们类推，我们B是二进制的意思，2是To，U是无符号数，T是补码。$$
4. $$ \omega 是要转换的位数.  T2B_\omega就是补码转二进制 $$
5. $$ TMin_\omega 最小补码值 $$
6. $$ UMin_\omega 最小无符号值 $$
7. $$ 同理，最大值就是TMax_\omega和UMax_\omega $$
### 2.2.3 无符号数编码
$$ 
B2U_\omega(\vec{x})=\sum\limits_{i=0}^{\omega-1}{x_i2^i}
$$
这是还是很简单，就不说上面了

### 2.2.3 补码的编码

$$ 
B2T_\omega(\vec{x})=-x_{\omega-1}2^{\omega-1}\sum\limits_{i=0}^{\omega-1}{x_i2^i}
$$

* $$ 补码最高有效位是符号位，它的“权重”为-2^{\omega-1}。符号位设置为1是，表示值为负，当设置为0时，值为非负。$$

需要注意：
1. 补码是不对称的:|TMin|=|TMax|+1, 也就是说，TMin没有对于正数.这会导致补码运算的某些特殊属性。
2. 最大的无符号数值刚好比补码的最大值的两倍大一.注意-1和UMax有同样的位表示.
### 旁注:有符号数的其他表示方法
* 反码: 
  $$ 除了最高有效位权是-(2^{\omega-1}-1)而不是-2^{\omega-1},它和补码是一样的 $$
* 原码: 最高位是符号位，用来确定这个数是正还是负.

这两种方法都有一个奇怪的属性，对于0有两种不同的编码方式。几乎所有现代机器都用了补码，我们将看到在浮点数中有使用原码编码。

### 2.2.4 有符号数与无符号数的转换

* 
$$
	对满足TMin_\omega \le x \le TMax_\omega的x有: 
	T2U_\omega(x)= 
\left\{
             \begin{array}{rr}
			 x+2^{\omega} , x<0& \\
			 x, x \ge 0
             \end{array}
\right.
$$
* 
$$ 
\\
对满足0 \le 0 \le UMax_\omega 的u有: 
	U2U_\omega(x)= 
\left\{
             \begin{array}{lr}
			 u ,& &{u\le {TMax}_{\omega}} \\
			 u-2^{\omega}, & &{u \gt TMax_{\omega}} \\
             \end{array}
\right.
$$

### 2.2.6 拓展一个数字的的位表示
* 无符号数的零拓展: 要将一个无符号数转换为一个更大的数据类型，我们只要简单地在表示的开头添加0，这种运算被称为0拓展
* 补码数的符号拓展：要将一个补码数字转换为一个更大的数据类型，可以执行一个符号拓展，在表示中添加最高有效位的值。

### 2.2.7 截断数字
* 截断无符号数: x'是x截断k位的效果。我们有
$$ x'=x\mod2^k $$
* 截断补码数, 
$$ x'=U2T_k(x \mod 2^k) $$
举个例子: 我们将x=53 191从int转换为short。 由于2的16次方=65 536>=x, 我们有 x mod 2^16 =x. 但是，当我们把这个数转换为16位的补码时，我们得到了x'=53 191 - 65 536=-12 345.

## 2.3 整数运算
### 2.3.1无符号加法
* 原理: 
$$ x+^u_\omega y=
\left\{
	\begin{array}{lr}
	x+y,& &{x+y \lt 2^\omega ,正常} \\
	x+y-2^\omega,& &{2^\omega \le x+y\lt 2^{\omega+1}，溢出} \\
	\end{array}
\right. $$
* 无符号数求反: 
$$ -^u_\omega x=
\left\{
	\begin{array}{rr}
	x,x=0& \\
	2^\omega-x,x>0
	\end{array}
\right. $$
### 2.3.2 补码加法
* 原理: 
$$ x+^t_\omega y=
\left\{
	\begin{array}{lr}
	x+y-2^\omega,& &{2^{\omega-1} \lt x+y,正溢出} \\
	x+y, & &{-2^{\omega-1} \le x+y\lt 2^{\omega-1}, 正常} \\
	x+y+2\omega, & &{x+y\lt -2^{\omega-1},负溢出}
	\end{array}
\right. $$
## 2.4 浮点数
### 2.4.2 IEEE浮点数
$$ V=(-1)^s\cdot M \cdot 2^E $$
* 符号(sign),s 决定这个数时负数(s=1),还是正数(s=0), 而对于数值0的符号位解释作为特殊情况.
* 尾数(significand) M是一个二进制小数，它的范围是
 $$1～2-\epsilon,或者0～1-\epsilon $$
* 阶码(exponent) E的作用是对浮点数加权，这个权重是2的E次幂（可能是负数)

注意几种情况
1. 规格化的值
   这个是最普遍的情况。当exp的位模式既不全为0（数值0),也不全为1（单精度数值为255,双精度为2047)时都属于这种情况。在这种情况下，阶码字段被解释为以偏置(biased)形式表示的有符号整数.也就是说，阶码的值是E=e-Bias,其中e是无符号数，而Bias是一个等于
   $$2^{k-1}-1$$
   的偏置值.

   小数字段被解释为小数值f,其中0<=f<1, 二进制小数点在最高有效位的左边，尾数的定义M=1+f. 这种房市也叫做隐含的以1开头的表示。
2. 非规格的值
   当阶码全部为0时，所表示的数时非规格化的形式。在这种情况下,阶码值时E=1-Bias,尾数M=f,也就是小数字段的值，不包含隐含的开头1.
3. 特殊值
   当阶码全是1的时候，且小数全是0时，得到的值为无穷，符号位可以将其值设置为负无穷和正无穷。当小数域不是全为0，结果值被称为"NaN"(not a number),一些运算不能是实数或无穷，就会返回NaN的值.


### 2.4.3 例子
我们假定有一个8位浮点格式，其中第一位是符号位，其次4位是阶码，最后三位是小数位.偏置量即为7.
* 非规格数
	1. 0 0000 000 E=-6, M=0, v=0
	2. 0 0000 001 E=-6, M=1/8,v=1/512
	3. 0 0000 011 E=-6, M=3/8,v=3/512
	4. 0 0000 111 E=-6, M=7/8, v=7/512
* 规格数
	1. 0 0001 000 E=-6, M=1, v=1/64
	2. 0 0110 110 E=-1, M=14/8, v=7/8
	3. 0 1110 111 E=7 , M=15/8, v=240
* 无穷大
  * 0 1111 000 v=无穷

### 2.4.4 舍入

* 向偶数舍入(round-to-even)：试图找到一个最近的匹配值

我们不想舍入整数时，也可以使用向偶数舍入。例如，1.234999 舍入到 1.23, 另一方面我们把两个数1.2350000 和1.2450000都舍入到1.24, 因为4是偶数

### 2.4.5 浮点运算

我们将 
$$x+^{f}y$$ 
定义为Round(x+y)。 这个运算的定义针对x和y的值，但是虽然x和y都是实数，由于溢出，该运算可以得到无穷值。可交换，不可结合。

假设一个编译器给定了如下的代码
```
x=a+b+c;
y=b+c+d;
```

编译器可能试图通过产生下列代码来省去一个浮点加法
```
t=b+c;
x=a+t;
y=t+d;
```
然而，对于x来说，这个计算可能会产生与原始值不同的值。在大部分应用中，这种差异小得无关紧要。

=> 旁注 Ariane 5 有一个惨痛的教训，将大的浮点数转换成整数是一种常见的程序错误来源，1996年6月4日，Ariance 5火箭初次航行，控制引擎喷嘴的计算机发送了一个无效数据。它没有发送飞行控制信息，而是送出了一个诊断位模式，表明在将一个64位浮点数转换成16位有符号整数时，产生了溢出。 溢出的值测量的是火箭的平均速率，这比早先的Ariane 4 火箭所能达到的高度高出了5倍，然后GG了。
