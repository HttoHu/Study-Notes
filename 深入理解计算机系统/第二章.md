# 第二章：信息的表示和处理

## 2.1 信息存储
* 大端法: 从左到右(我们人类喜欢的顺序)
* 小端法: 从右到左
```c
#include <stdio.h>

typedef unsigned char* byte_pointer;
void show_bytes(byte_pointer start, size_t len)
{
	size_t i;
	for (int i = 0; i < len; i++)
		printf(" %.2x", start[i]);
	printf("\n");
}

void show_int(int x)
{
	show_bytes((byte_pointer)& x, sizeof(int));
}

void show_float(float x)
{
	show_bytes((byte_pointer)& x, sizeof(float));
}


void show_pointer(void* x)
{
	show_bytes((byte_pointer)& x, sizeof(void*));
}

```

以上代码显示一个数值的16进制，你可以用来检测你的机器使用大端还是小端

## 2.1.9 C语言中的位移运算
* 左移: 对于一个位表示
$$ 
    [x_{\omega-1},x_{\omega-2},x_{\omega-3},...,x_0]的操作数x,C表达式x<<k会生成一个值，其位表示为
    [x_{\omega-k-1},x_{\omega-k-2},x_{\omega-k-3},...,x_0,0...,0]. 也就是说，x向左移动k位，丢弃最高的k位，并在右端补上k个0.移动量应该是0-\omega-1的值.
$$
* 右移：右移分为逻辑右移和算数右移。逻辑右移就是在左端补k个0，算术位移就是在左端补k个最高有效位的值。
* 移动k位，这里k很大我们对一个n位的数据x移动k位,k>n,我们执行x>>k这里首先实际上计算了x>>(k mod n), 同理<<也是如此.

## 2.4 浮点数

### 2.4.4 舍入

* 向偶数舍入(round-to-even)：试图找到一个最近的匹配值

我们不想舍入整数时，也可以使用向偶数舍入。例如，1.234999 舍入到 1.23, 另一方面我们把两个数1.2350000 和1.2450000都舍入到1.24, 因为4是偶数

### 2.4.5 浮点运算

我们将 
$$x+^{f}y$$ 
定义为Round(x+y)。 这个运算的定义针对x和y的值，但是虽然x和y都是实数，由于溢出，该运算可以得到无穷值。可交换，不可结合。

假设一个编译器给定了如下的代码
```
x=a+b+c;
y=b+c+d;
```

编译器可能试图通过产生下列代码来省去一个浮点加法
```
t=b+c;
x=a+t;
y=t+d;
```
然而，对于x来说，这个计算可能会产生与原始值不同的值。在大部分应用中，这种差异小得无关紧要。

=> 旁注 Ariane 5 有一个惨痛的教训，将大的浮点数转换成整数是一种常见的程序错误来源，1996年6月4日，Ariance 5火箭初次航行，控制引擎喷嘴的计算机发送了一个无效数据。它没有发送飞行控制信息，而是送出了一个诊断位模式，表明在将一个64位浮点数转换成16位有符号整数时，产生了溢出。 溢出的值测量的是火箭的平均速率，这比早先的Ariane 4 火箭所能达到的高度高出了5倍，然后GG了。
